* 1, lecture 1, 2020-09-02
Recap OOP (references, wrappers, generics, interfaces), Abstract datatypes, interator

** 22:00
What is object-oriented program
    - modeleren van de echte wereld
    - collecties van van samenwerkende objecten
        - air traffic control system: aircraft, airport, flight, scheduele
        - account management system: customer, account, transaction
        - word processor: character, word, paragraph, font, format
    - for medium to large problems

** 23:30
Abstraction
    - thinking about something as an idea
    - ignoring irrelevant details and ephasizeing essential ones
    - think about component withouth worrying about detail
    - taking out essentials which are common to all types
        - abstract car is composed of abstract engine, abstract wheels
        - color is inrelevant detail to the idea of a car

** 24:00
Modularisation
    - breaking down, a program or anything, into manageable pieces
    - smaller components - easier to deal with
    - with a smaller class it's easier to test
    - easier to collaborate in a team

** 25:00
Object oriented systems
    - composite, modular, and organised around data
    - classes represent a piece of data
    - best strategy for large, evolving software systems
    - forces design before coding

** 26:00
Objects
    - fundamentele abstractie waar op we onze systemen bouwen
    - instantie van een class in het geheugen
    - karakter eigenschappen
        - staat
            - velden
        - gedrag
            - methodes
        - identiteit
            - hoe we verwijzen naar de object

** 27:00
Classes
    - sjabloon, specificatie, voor een object
    - specificeert de eigenschappen van een groep vergelijkbare objecten

** 28:00
Relations between objects
    - objecten werken samen en zijn verbonden met andere objecten
    - minimalizeren van korte koppeling, hoge afhankelijkheid van elkaar
    - zonder interactie geen werkend systeem
    - associatie
        - associatie met ander object
        - mogelijke kardinaliteit
        - objecten kunnen los van elkaar bestaan
    - aggregatie
        - groepeering van objecten
        - mogelijkheid los van elkaar bestaan
        - kan tijdelijk deel uitmaken
    - compositie
        - samengestelde groep van onderdelen
        - kunnen niet los bestaan
        - vaak korte koppeling
    - erfenis
        - object stamt af van ander object (ouder kind relatie)
        - korte koppeling
        - sub-classing
            - functionaliteit toevoegen

** 35:00
Fundamentele eigenschappen van een object georienteerde taal
    - erfenis (inheritance)
        - afstammen van andere objecten
        - methode overschrijven
            - overschrijven van geerfde methodes
            - methode behoud de zelfde naam in ouder en kind klas
            - dynamische binding die polymorfisme toestaat
    - inkapseling (encapsulation)
        - beperken of controlle over de manier dat objecten gemanipuleerd worden
        - private properties, public get / set
    - polymorfisme (polymorphism)
        - vermogen van een object om verschillende vormen aan te nemen
        - zorgt voor minder korte koppeling van erfenis

Abstractie (abstraction)
    - abstract class
        - klas die niet geïnstantieerd kan worden
        - initialiseren van de klas is niet wenselijk of logisch
        - voorbeeld: vorm
        - defineert een type
        - heeft een ouder en kan ouder zijn van een (abstracte) klas
        - heeft een constructor
        - kan (abstracte) methodes hebben
        - kan instance fields hebben
    - interface
        - is belove van gedrag (methodes)
        - pure abstracte klass om alleen gedrag van een klass te defineren (method signature)
        - geeft minimale functionaliteit
        - geen constructor
        - alleen abstracte methodes
    - zorgen voor lagere koppeling tussen objecten
    - veel ontwerp patronen zijn hier op gebaseerd
    - abstracte data types
        - een datatype waar van de implementatie van de methodes verborgen is
        - bevat data specifiek voor een instante van de abstrate data type
        - bevat methodes om deze data te bewerken
        - is ingekapseld, toont slechts enkele van de subprogramma's
        - bijvoorbeeld: een list object gebruikt een array, laat gebruiker de array middel van een interface bewerken
            - voorkomt het bijwerken van indices door gebruiken

** 50:00
Grouping object
    - nodig in veel applicatie voor het bijhouden van objecten
    - kenmerken van een collecties
        - aantal items om op te slaan is niet vastgesteld
        - mogelijkheid om items to te voegen / verwijderen
    - mogelijke eigenschappen
        - toevoegen, verwijderen, vinden, opvragen, tellen

** 54:00
Java collections API
    - Java implementatie van abstracte data types: java.util.Collection
    - gebaseerd op AbstractCollection, implementeerd Collection
    - bevat bijna ieder type van collectie
    - overzicht van enkele collecties
        - ArrayList: Resizable array – grows in increments
        - Hashmap: A collection of [key, data] pairs – order not guaranteed
        - HashSet: Set implemented using a hash table – order not gtd
        - Hashtable: A collection of [key, data] pairs – order not guaranteed
        - LinkedList: A linked list
        - Stack Last: In First Out (LIFO) data structure
        - TreeMap: [key,data] pairs held in ascending order
        - TreeSet: Set implemented as a tree
        - Vector: Resizable array – synchronised access
** 62:00
Geparametriseerde abstracte datatypes
    - Java is een statisch getypeerde programmeertaal, types moeten van te voren gedefineerd worden
    - generic
        - zorgen er voor dat een type pas later gespecificeerd kan worden
        - functioneren als parameter voor wanneer een datatype geinitialiseerd word
        - zonder zou de collection ieder Object kunnen vasthouden
            - controlleert niet het type bij het toevoegen, alles wordt als Object behandeld
            - moet gedowncast worden bij het ophalen
        - wordt verklaard in de klas declaration

** 69:00
Iterable
    - interface geimplementeerd door een collectie dat Iterator returned
    - Iterator
        - interface met hasNext() en next() methode
        - private class binnen de collectie
    - alternatief: gebruik .size() en loop door de indices
    - for each loop is shorthand voor een while loop met iterator
    - rekening houden met:
        - time complexity: relatie tussen aantal elementen en tijd
        - memory complexity: relatie tussen aantal elementen en ruimte
        - order of complexity

** 80:00
Primitive types
    - collecties kunnen geen primitieve types behouden, ze zijn geen object
    - wrapper class: houd de primitieve type vast
        - int: Integer
        - zijn trager dan primitieve types
        - heeft ook methodes als parseInt
        - Autoboxing
            - primitieve types worden automatisch in een wrapper geplaatst


* 2, lecture 2, 2020-09-09
Recursion (induction)

2:00
Methode roept zichzelf aan
    - Je krijgt een soort oneindige loop
    - stop conditie
        - bepaald hoe de oneindige loop eindigd

** 13:00
Nodig
    - recursie is nodig voor het sommige oplossen
    - bijvoorbeeld het het doorlopen van een tree, of het vinden van grootste gemene deler.

** 16:00
Statement order
    - belangrijk
    - bepaald hoe de data gemanipuleerd word
    - recursieve methode wordt eerst uitgevoerd voor dat de rest van de methode

** 20:00
Groots gemeende deler
    - methode met input a en b
    - check of b gelijk is aan 0
    - als dat klopt dan is a de groots gemeende deler
    - ander roep de methode aan met b en a modulo b

** 33:00
Methode aanroepen
    - een methode bestaat uit code en data
    - data
        - bestaat uit parameters en locale variabelen
        - wordt opgeslagen
    - stack frame
        - voor elke methode aanroep wordt er een nieuwe aangemaakt
        - bevat een retouradres
        - weg gegooid na dat de methode is uitgevoerd

** 39:00
Recursie gebrui
    - om het concept van recursie te begrijpen hoef je niet te weten hoe het werk
    - het is genoeg om te weten wat een recursieve methode doet
    - recursie is te vergelijken met wiskundige inductie
    - een recursieve methode volgt vaak de natuur van de data

** 41:00
    - bottom up: werk van beneden naar boven
    - top-down: werk van boven naar beneden
    - bisection: roep twee keer recursie van af het midden

* 3, lecture 3, 2020-09-16
List, ArrayList, LinkedList, Linear Search, Binary Search

** 01:00
List
    - is een abstracte data type
    - omdat je het op meerdere manieren geimplementeerd kan worden

** 05:00?
ArrayList
    - een list gebaseerd op een array
    - door middel van een lengte variable hou je het laatste element in de array bij
    - constructor
        - initialiseer array (met zelf bedachte lengte, en lengte variable
    - toevoegen
        - Vergelijking lengte variable met lengte van de array
        - wanneer dat groter is maak nieuwe array met dubbele grote en vervang oude array
    - verwijderen
        - check opgegeven index
        - verplaats alle elementen die na de index komen een terug
        - verlaag de lengte variable met een

** 65:00
LinkedList
    - gebruikt geen array
    - elementen worden in nodes opgeslagen die onderling gelinked zijn
    - node is een prive klasse binnen de lijst klasse en heef een next propertie naar de volgende node
    - list houdt de eerst en laatste node bij
    - toevoegen
        - node aanmaken en als er nog geen nodes bestaan toevoegen als head node
        - anders aan de next laatste node toevoegen
        - laatste node vervangen met nieuwe node
    - terughalen
        - begin bij head en blijf optellen naar de volgende node
        - return node wanneer gewenste index is bereikt
    - exists
        - loop van af head over next, als er een match is return true
        - anders return false
    - delete
        - van af head lopen naar gewenste node
        - laatste bezichte node bijhouden
        - wanneer er een match is laat de laatste bezochte node naar de next node verwijzen
    - types
        - singular: ieder node refereerd naar de volgende node
        - double: iedere node refereerd naar de volgeende en vorige node
        - circular: de laatste node refereerd weer naar de eerste node

voordeel
    - linkedList
        - toevoegen sneller, hoeft geen array gecopieerd te worden
        - delete sneller, kleine verandering, begin van collectie is beter
    - arrayList
        - get en exists sneller, kan direct index opvragen
        - delete langszamer, veer variablen verplaatsen, einde van collectie is beter

Linear search
    - begin aan de voorkant en checkt iedere variable tot laatste item
    - snelheid afhankelijk van positie in collectie

** 96:00
Binary search
    - de collectie waar in je zoekt moet gesorteerd zijn
    - split de collectie in tweeën
    - als de waarde lager / hoger dan het midden is, split dan de lage / hoge helft
    - tot dat je bij het doel uitkomt


* 4, lecture 4, 2020-09-23
Big-O efficiency, simple sorts, comparator
Liang 22.1 - 22.7

** 03:30
birthday paradox
    - oplossing 1
        - sla datums op in een array
        - check alle datum tegen elkaar met een double for-loop
        - efficiëntie
            - tijd: O(n^2): stijging exponentieel
            - geheugen: O(1), er wordt niets opgeslagen
    - oplossing 2
        - dates opslaan in array van 366 dagen met waardes 0
        - voor iedere datum zet dayOfYear in array naar 1
        - als een dayOfYear als 1 is heb je een match
        - efficiëntie
            - tijd: O(n) stijging blijft constant
            - space: gebruikt meer geheugen, zeker in vergelijking met weinig dates

** 12:00
Efficientie
    - als je iets efficient maken is het een afwezing kwa tijd, of geheugen
    - hoge tijd efficientie betekend vaak lage space efficientie
    - hoge space efficientie betekend vaak hoge tijd efficientie

** 13:00
Two sides
    - wisselwerking tussen algoritme en data structuur
    - afhankelijk algoritme kan je een bepaalde data structuur kiezen
    - of afhankelijk van je data structuur heb kan het zijn dat je een bepaald algoritme moet kiezen
    - method to solve -> algorithm
    - storge of data -> data structure
    - bijvoorbeeld: binare boom, linked list hebben eigen efficiente algoritmes

** 14:00
Algoritme
    - informele definitie: stap voor stap methode om een probleem op te lossen; recept
    - geeft een andtwoord op je probleem
    - bijvoorbeeld
        - hoe bak ik een cake
        - bereken de volume van een vorm
        - vinden van data in een grote database
        - sorteren van een set data

** 16:00
Data structuur
    - manier waar op je de data op de computer hebt opgeslagen
    - implementatie van data opslag
    - bijvoorbeeld: Array, List, Stack, Queue, HashMap, Tree, Graph

** 20:00
Efficientie van een array
    - toevoegen
        - aan het einde van array een element toevoegen
        - is ogenblikkelijk, onafhankelijk van lengte
    - vinden
        - elk element vergelijken tot dat je een match heb
        - gemiddel vergelijk je de helft van de elementen in de array
        - twee keer zo lange lijst betekend twee keer zo veel vergelijken
    - verwijderen
        - elk element na het te verwijderen element een terug verplaatsten
        - ongeveer gelijk aan het vinden van een element

** 28:00
Algoritmische complexitie
    - tijd complexiteit: relatie tussen aantal elementen en benodigde tijd
    - ruimte complexiteit: relatie tussen aantal elementen en geheugen
    - tijd-ruimte trade off, afweging tussen de twee
    - volgorde van complexiteit

** 30:00
    - contstant time, onafhankelijk hoe veel items, het duur altijd even lang

** 42:00
    - dubbele for loop is kwadratish

** 44:00
Time complexity JVM
    - java optimaliseert de code in de Java Virtual Machine
    - controleerd uitkomsten van functies, en maakt aanpassingen als hij repetities ziet
    - Just In Time programming
    - Uitzetten met -Xint

** 47:00
Order of time complexity: big O
    - order van grote
    - linear search, van orde n, dus  O(n)
    - binary search, van orde log n, dus  O(log n)
    - log is het tegenovergesteld van exponentieel, stijgt steeds minder snel
    - kwadratisch
        - stijging is exponentieel, twee keer zo veel betekend vier keer zo veel complexiteit
    - nauwkeurigheid
        - complexiteit = O(1 + n + n^2) -> O(N^2)

** 57:00
Sorting

** 58:00
Selection sort
    - selecteer het kleinste element, vergelijk met alle elementen in collectie
    - verwissel met het eerste ongesorteerd element in de collectie
    - herhaal tot dat alles gesorteerd is
    - complexity O(n^2)

** 63:00
Insertion sort
    - pak het meest linker element uit het ongesoorteerde deel
    - vergelijk met laatste element in gesorteerde deel tot dat je een hoger element vind
    - paats het op de juiste plek in het gesorteerde deel
    - herhaal tot ongesorteerde deel leeg is
    - complexity O(n^2)

** 71:00
Bubble sort
    - complexity O(n^2)
    - staan elementen goed, gebeurt niets, anders verplaatsen
    - vergelijk eerst eerst en tweede, dan tweede en derde
    - stappen
        - verplaatst grootste element naar rechts
        - herhaal tot dat alles op de juiste plek staat

** 72:00
Comparing basic sorts
    - best case en worst case
    - afhankelijk van initiale volgorde van elementen
        - almost sorted, reverse, random
    - constante tijd is ideal, maar bijna nooit haalbaar

** 78:00
Overzicht big O
    O(1) & constant
    O(log n) & logaritmic
    O(sqrt(n)) = O(n^0.5) & sqrt n
    O(n) & linear
    O(n log n) & n log n
    O(n sqrt(n)) = O(n^1.5) & n sqrt n
    O(n^2) & quadratic
    O(n^3) & n to to power of 3
    O(a^n) & 57

** 79:00
Comparable en comparator
    klasse die deze implementeerd vergelijkbaar is met andere instantie van de klasse
    - comparable
        // - klasse die dit implementeerd vergelijkbaar is met andere instantie van de klasse
        - klasse maar op een manier vergelijken
        - compareTo
            - implementeer methode in de klasse
            - heeft een ander object als parameter
            - returned een integer
            - als de huidige instantie voor de meegegeven instantie moet komen return iets kleiner dan 0
            - als de huidige instantie gelijkwaardig is aan de meegegeven instantie return 0
            - als de huidige instantie achter de meegegeven instantie moet komen return iets groter dan 0
    - comparator
        - extra sorteer klasse
        - Voor vergelijken van twee instanties van klasse
        - heeft een compare methode, met twee parameters
        - kan ook binnen de klasse die je wil sorteren
    - standaard java class
        - geimplementeerd
        - natuurlijke ordering

* 5, lecture 5, 2020-09-30
MergeSort, QuickSort selection sort, insertion sort, shellsort, mergesort, quickset, heapsort

** 14:00
Quicksort
    - eigenschappen
        - meest gebruikte sorteer algoritme
        - niet (zo) moeilijk te implementeren
        - werkt goed onafhankelijk van input data
        - in place, heeft geen extra ruimete nodig
        - Efficientie is O(N log N)
        - devide and conquer
        - paritie de array in twee kleinere arrays
        - recursief
    - partitioning
        - selecteer een pivot, meestal het eerst element
        - zoek van af de voorkant tot je een waarde vindt boven de pivot
        - zoek van af de achterkan tot je een waarde vindt die boven de pivot is
        - vervang deze twee posities en herhaal
        - wanneer ze elkaar in het midden vinden verplaats de pivot hier naar toe
        - return de positie van de pivot
    - stap
        - shuffle de collectie
        - kies een pivot, element waar mee je gaat vereglijken, uit de collectie
        - splits de collectie op in waardes groter en kleiner dan pivot.

** 63:00
Merge sort
    - recursief
    - Opsplitsen van collectie
    - stappen
        - begin met twee gesorteerde collecties
        - vergelijk de eerste waardes van de twee collecties
        - zet de waarde die eerst komt in de gesorteerde array
        - herhaal met de volgende positie van de array waar je de waarde uit hebt gehaald.
    - buttom up
    - meer over opzoeken

sort worst average best
selection n^2/2 n^2/2 n^2/2
insertion n^2/2 n^2/4 n
merge nlogn nlog nlognn
quick n^2/2 2nlogn nlogn
3-way quick n^r/2 nlogn nlogn

* 6, lecture 6, 2020-10-07
Stack, Queue, Priority Queue, Heap

double ended queue

** 03:00
Stack
    - wat er als eerste in gaat komt er als eerst uit
    - weg terug vinden, als je een dood punt vindt terug lopen naar laatste kruispunt
    - undo, redo, als je undo uitvoert komt de acties op de redo stack
    - recursie gebruikt stack, zo dat het weet waar het terug moet komen
    - first in, last out FIFO, last in, first out LIFO
    - operations
        - push: toevoegen aan het eind
        - pop: afhalen aan het eind
        - isEmpty: controlleer leeg
        - peek: kijken naar laastste waarde
        - size: grote
    - voorbeeld functie: een woord omdraaien, alle letters pushen op een stack en poppen>
    - implementatie: array, ArrayList / LinkedList

** 23:00
Queue
    - achterkan er bij, voorkant er af
    - printer queue, ticket / message verwerken op een server
    - first in, first out (FIFO)
    - operations
        - enqueue, toevoegen aan het begin
        - dequeue, verwijderen aan het eind
        - isEmpty, controleer leeg
        - size, grote
    - implementatie met array
        - int variable voor begin en eind
        - bij enqueue verhoogd eind variable
        - bij dequeue verhoog start variable
        - als eind variable einde array bereikt begin opnieuw in array als begin variable hoger is
        - als array vol is verdubbel de lengte
    - implementatie met LinkendList
    - in principe is efficiency constant, tot dat array verlengt wordt

** 53:00
Deque
    - Double ended queue
    - kan aan het begin en einde toevoegen en verwijderen

** 70:00
Priority queue
    - werkt ongeveer als een que, first out
    - items gesorteerd op waarde
    - hoge priority items gaan naar het einde van de queue
    - toevoegen
        - methode moet aangepast worden
        - vergelijken met bestaande waardes
        - O(n)
** 73:00
Hheap
    - berg
    - structuur binary tree: graaf met twee children per node
    - complete / dense: eerst bovenliggende lagen vol zijn
    - node waarde moet hoger zijn als de waardes van kinderen
    - implementatie array
        - eerst item begin op 1
        - per level gebruik je het dubbele aantal indices
        - left child = index * 2
        - right child = index * 2 + 1
        - parent = index / 2
    - gevolgen
        - elk pad van root geeft ordered list
        - geen traversal mogelijk, weakly ordered
        - verwijderen van grootste makkelijk
            - snelle verwijderen van maximum
        - snel nodes toevoegen
    - verwijderen van maximum
        - return index 1
        - zet laatste node op index 1
        - voer sink methode op index 1 uit
    - sink laten zakken naar de juiste positie
        - vergelijk hoogste child
        - check of hoogste child hoger is dan parent, ander ben je klaar
        - verplaats met hoogste child node
        - herhaal tot er geen childs meer zijn
    107:00
    - insertion
        - voeg element toe aan einde van de array
        - swim toegevoegde node
    - swim (tricle) verplaatsen naar de correcte positie door te vergelijken met parent
        - als parent lager is swap posities
        - herhaal tot parent hoger is
    - efficiency
        - toevoegen O(log n)
        - verwijderen O(log n)
        - zoeken / verwijderen O(n)


* 7, lecture 7, 2020-10-21
Hashing, Sets, Maps

** 04:00
Collection interface
    - Set interface implementeerd de collection interface

** 07:00
Set
    - in een set is elk element uniek
    - heeft geen volgorde
    - bijvoorbeeld: studenten in een team
    - operaties
        - add: toevoegen als het nog niet bestaat
        - remove: verwijder als bestaat

** 15:00
TreeSet
    - gebruikt boom strucuur om elementen op te slaan
    - moet Comparable implementeren om te vergelijken of element al bestaat
        - alternatief kan je een comparator toevoegen aan de contructor

** 23:00
HasHSet
    - afhankelijk van `hashCode` en `equals`, geen comparator

** 27:00
Hash
    - als methode equals waar is moet hashcode hashCode hetzelfde geven
    - als methode equals niet waar is kan de hashCode anders zijn
    - wanneer equals niet is geimplementeerd wordt de functie van de super klasse gebruikt
    - als er geen super klasse is wordt door de object klasse de locatie in het geheugen (referentie) gebruikt

- hashCode
    - methode die een integer returned
    - een integer in de Interger.hashCode opgeven is onnodig

** 43:00
Equals
    - controller of object is huidige instantie is, return true
    - controller of object niet null is en of het object geen instantie is van het huidige object, return false
    - cast object naar de klasse van huidige instantie
    - controller of identificerende velden gelijk zijn

** 52:00
Set operations
    - union: addAll
    - subset: containsAll
    - intersection: retainAll
    - minus: removeAll

** 55:00
Static factory methods
    - Set.of(...), maak een set van variables
    - List.copyOf(...)

    - List.of(...), maak een list van variables
    - set.copyOf(...)

** 57:00
Hashing 1
    - scramble / map een waarde van een object naar een code
    - consitent: dezelfde waardes moet altijd op hetzelfde code uitkomen
    - onomkeerbaar: kunt niet de orginele waarde van de code krijgen

** 59:00
Hashing 2
    - operatie dat een waarde verstrooid / mapped naar een willekeurige integer, consitent en mogelijk onomkeerbaar
    - verstrooid: verbeel de waardes gelijk over beschikbare integers
    - mogelijk onomkeerbaar: duplicaten kunnen bestaan maar het lieft zo weinig mogelijk
    - hash gebaseerde data structuren: HashSet, HashMap

** 61:00
stappen voor HashSet of HashMap
    - steutel gaat door hash function
    - de hash code gaat door modulo array size
    - de array index wordt gecontrolleerd op collissions
    - uiteindelijke index

** 63:00
Voorbeeld
    - nummerbord van 31 auto's
    - combinatie twee cijfers en een letter
    - geef letters een waarde van 1 tot 26
    - hashCode berekennen: letterwaarde * 100 + nummerwaarde
    - hashCode % 31 = index

** 65:00
Collisions
    - overeenkomende hashCode van twee verschillende waardes
    - kan niet voorkomen worden
    - oplossingen:
        - open addressing
            - linear probing
                - als een plek bezet is ga naar de volgende plek
                - herhaal tot dat er een plek vrij is
                - nadeel: clustering
            - quadratic probing
                - als er een plek bezit is tellen we daar n kwadraad bij op, beginnend bij en
                - verhoog iedeer keer n tot dat er een plek vrij is
                - nadeel: geen primare clustering maar wel secondaire clustering
            - double hashing
                - linear en quadratic probing geven dezelfde stap volgorde voor alle keys
                - genereer een stap grode afhankelijk van de key
                - andere hash methode dan de primaire hash methode
                - zorg er voor dat je geen stap grote krijgt van 0
                - stepSize = 1 + hash2(key) % CONSTANT
                - constante niet groter dan de grote van de array
        - separate chaining
            - als hashCode op dezelfde index uitkomt stop ze samen in een LinkedList
            - nadeel: lijst kan lang worden
            - geen cluster problemen
            - datastructuur is complexer
** 76:00
Een goede Hash functie kiezen
    - afhankelijk van de omvang en verdeling van de waarde
    - perfecte hash functie: elke key gaat naar een apparte locatie, geen collisions
    - vereisten
        - consistent
        - efficient te berekennen
        - uniform verdeeld 0 tot MAX_INT
    - voorbeeld
        - goed: laatste drie cijfers
        - slecht: eerste drie cijfers

** 78:00
grote onderlinggende array
    - gadviseerd een priemgetal als grote te kiezen
    - java resize
        - automatisch als inhoud meer dan 75% is
        - vergroot in macht van 2
        - inhoud opnieuw gehashed

** 79:00
Java object.hashCode()
    - returned een integer tussen MIN_VALUE en MAX_VALUE
    - String classe berekend hashCode op basis van berekening met karakter code
    - Integer returned zijn de waarde in HashCode

** 83:00
Hashing in Java
    - ieder klass inheirit Object.hashCode()
    - requirement: if x.equals(y), then (x.hashCode() == y.hashCode())
    - desirable: if !x.equals(y), then (x.hashCode() != y.hashCode())
    - standaard memory adress van x

** 85:00
Performance
    - betere spreiding in hashCode levert betere performance

** 86:00
Map
    - sleutel-waarde paar abstractie
    - waarde invullen met gespeceficeerde sleutel
    - waarde opvragen met geven sleutel
    - voorbeeld: DNS, geef een domein naam en krijg ip adres

** 88:00
Java Map
    - interface met generics K (key) en V (value)
    - types
        - HashMap, op basis van HashCode en equals
        - TreeMap, op basis van comparable of comparator

** 89:00
hashMap
    - items opgeslagen in array
    - gebruikt sleutel van items
    - zoeken met key in array index
    - voordeel: snel toevoegen en zoeken
        - constante tijd: O(1) als er geen collisions zijn
    - nadeel: moeilijk te vergroten, geen manier om items op volgorde te bekijken
    - methods
        - get, krijg waarde terug of null
        - getOrDefault, geeft waarde of als die niet bestaat een default waarde
        - put, voeg een waarde toe met een key
        - putIfAbsent, voeg een waarde toe als die nog niet bestaad
        - remove, verwijder de sluitel uit de map
        - containsKey, controlleer of sleutel er in zit
        - containsValue, controller of waarde er in zit

** 98:00
Map Collection acces methods
    - keySet, geeft een set van keys
    - values, geeft een collectie van waardes


* 1, lecture 8, 2020-11-11
Functional interfaces, Lambda expressions, builder pattern

** 01:30
Comparator revisited
    - collecties kunnen gesoteerd worden door gebruik te maken van een helper object dat de Comparator implementeerd
    - compare
        -  0 if a1 equels a2
        - <0 if a1 precedes a2
        - >0 if a1 succeeds 2
    - interface contract uitbreiden voor functionele interface
    - comparator is een klasse zonder inkapseling dat maar een functie heeft
        - dat is een functionele interface

** 06:00
    - elke interface met een enkele abstracte methode is een functionele interface
    - functionele interface
        - de functie is om een intuitieve manier om functies door te geven, naast data objecten
        - geeft alleen toegang tot een enkele functie
            - klasse met enkele methode, zonder ingekapselde data
            - is abstract tot je het realize (define)

** 07:00
Vier variaties
    - (traditioneel) geef een object instantie die de interface implementeerd
    - geef een referentie naar een statische methode
    - geef een referentie naar instantie methode
    - geef een lambda expressie

    - vier manieren om de zelfde code mee te geven aan een functie
    - java compiler transformeert elk van de nieuwe syntax contsructies naar een anoniem object instantie dat de functionele interface implementeerd.

** 08:00
Classic example
    - sort method krijgt een geinitialiseerde klasse van Comparator meegegeven
    - sort(new Author.CompareByInitials());
    - public static class CompareByInitials implements Comparator<Author> { ... }

** 09:00
Geef een referentie naar een statische methode
    - vergelijk twee objecten
    - .sort(Author::compareByInitials2)
    - :: = referentie naar statische methode
    - public static int compareByInitials2(Author a1, Author a2) { ... }

** 13:00
Geef een referentie naar een instantie methode
    - vergelijk object met huidige instantie
    - .sort(Author::compareByInitials)
    - public int compareByInitials(Author o) { ... }

** 15:00
Geef een lambda expressie
    - suprise methode, defined on the fly
    - inline gedefineerde functionele interface
    - .sort( (a1, a2) -> { ... })

** 26:00
Origin of Lambda
    - mathematical formalism in theoretical computer science
    - it 'proves' the outcome of calculations by manipulation of functional expresisons

** 28:00
Lambda in Java
    - compacte notatie om instanties van functionele intefaces te maken
    - ook genoemd: arrow notation, anonymous function
    - format: parameters list -> expressie afhankelijk van parameters
    - voorbeeld:
        - UnaryOperator<Double> function with type T that returns type T
            x -> Math.sqrt(x)
        - BinaryOperator<Double> function with two parameters that returns the same type
            (x, y) -> {
                print(x, y);
                return Math.max(x, y);
            }
** 34:00
Predicate
    - functionele interface met parameter dat een boolean terug geeft
    - handig voor onder andere filter criteria
    - BookRegister
        - public Set <Book> findBooks(Predicate<Book> filter) { ... }
    - bookRegister.findBooks(book -> book.yearOfIssue < 2000)

** Overzicht
je moet de methode namen van de functionele interfaces
    Predicate<T>    methode met een argument van type T dat een boolean terug geeft     p.test(t)
    Function<T, R>  methode met een argument van type T en een type R terug geeft   f.apply(t)
    BiFUnctino<T, U, R> een functie met twee argumenten van type T en U dat een type R terug geeft  bf.apply(t, u)
    Supplier<R>     (producer) methode zonder argument dat een type R terug geeft   s.get()
    Consumer<T>     methode me een argument van type T dat niets terug geeft    c.accept(t)
    BiConsumer<T, U>    methode me een argument van type T en U dat niets terug geeft   bp.test(t, u)
    unaryOperator<T>    methode met een argument van type T dat type T terug geeft  uo.apply(t)
    BinaryOperator<T>   methode me twee agumenten van type T en dat type T terug geeft  bo.apply(t1, t2)
    Comparator<T>       methode met twee argumenten van type T dat een interger terug geeft     co.compare(t1, t2)

** 45:00
Functional interfaces in collections
    - Collections hebben forEach met een Consumer<T> parameter
        - print items in collectie: collection.forEach(System.out::println)

** 52:00
Map advandced operators
    - compute(key, remappingFunction): returned een getransformeerde gemapped
      waarde, door gebruikt te maken van de gegeven fransformatie functie
    - merge(key, value, operatorFunction): combineerd de bestaande mapped
      waarde met de gegeven waarde door gebruik te maken meegegeven operator
      functie, slaat de waarde op en geeft je het resultaat.
    - forEach(action): Voert de actie functie uit voor ieder sleutel-waarde paar in de map
    - replaceAll(remappingFunction): vervang alle gemapte velden met het
      resultaat van het toepassen van de remapping methode on elke sleutel-waarde in de map

** 54:00
merge
    - voert de meegegeven functie uit als bestaande waarde niet null is
    - bookCount.merge(a, 1, Math::addExact);

** 64:00
Default methods in interfaces
    - verlicht de last om minder relevante methoden te implementeren
    - zorgt er voor dat je abstract kan zijn en een default implementatie te hebben
    - interface Vehicle { ... }
        - default void print() { System.out.println("I am a vehicle") }

** 66:00
Compositie van functie
   - and( ... ): combineer twee predicates
   - andThen( ... ) voer de tweede functie uit op basis van de uitkomst van
     de eerste functie

** 74:00
Builder patern
    - Een klasse met als enige doel te assisteren in het incrementeel maken van object van
      een andere klasse
    - managen van het maken van complexe objecten, stap voor stap
    - integriteit waarborgen
    - facaliteren van het maken van objecten van verschillende invoer of
      verschillende representatie
    - verbeteren performance van object aanmaken
    - verbeteren van leesbaarheid van de code voor complexe objecten

    - interne klasse waar in een collectie waar instantie van collectie wordt
      opgebouwd

** 77:00
StringBuilder
    - gebruik append methode om toe te voegen
    - toString methode om de string te bouwen

** 78:00
Builder pattern voorbeeld
    - boek registratie
    - voorkomen van dublicate auteurs
    - auteur van boek laten verwijzen naar de zelfde autheur object

* 2, lecture 9, 2020-11-18
Streams, Collectors, Method chaining

** 01:00 Stream
    - sequentie van elementen dat geaggregeerde operation ondersteund
    - andere manier om een for each te doen 
    - geeft een compacte notatie van pipeline verwerking van een reeks waarden

** 03:00 voorbeeld
    - begin met een collectie
    - .stream() veranderd het in een stream
    - verwerkt items eens per keer
    - tussenliggende stream-bewerkingen
        - filter() methode met functionele interface als parameter
        - je kan functies doen die een stream terug geven
    - terminal operation
        - count() methode
        - geeft waarde terug

** 06:00 Lazy
    - bewerking op de data bron wordt alleen uitgevoegd wanneer de terminal
     operation is begonnen 
    - bron element zijn alleen gebruikt wanneer ze nodig zijn
        - een element gaat door de complete pipline voor het volgende element
          opgevraagd wordt
        - verbeterde rekenprestaties worden in acht genomen (paralel stream)
    - geheugen footprint van meeste geleverde stream operations is O(1)
        - betekend dat grote data bronnen verewerkt kunnen worden met lage
          geheugen voetprint 

** 09:00 Method chaining
    - ook bekend als dot-chaining
    - flexibel voor toepassen combinatie van operaties in elke volgorde
    - verbeterd code beknoptheid en leesbaarheid 

** 11:00 Every collection can be streamed
    - collection interface implementeerd stream() en parallelStream
    - parallelStream gebruikt multi-threading op meerde processor kernen om
      uitvoering te versnellen
      - vereist is dat de code thread-safe is (nu niet gebruiken)

** 16:00 stream operators
    - mappers en reducers
    - mapper
        - intermediate methode
        - selecteerd en transformeert waarden 
        - levert een andere stream terug
        - methods
            - map(Function<T, R>)
            - mapToInt()
            - mapToDouble()
            - filter(Predicate<T>)
            - distinct
            - limit(maxSize)
            - flatMap(Function<T, Stream<R>>)
    - reducer
        - final method
        - verzameld / combineert waardes
        - levert een data waarde
        - methods 
            - anyMatch(Predicate<T>)
            - allMatch(Predicate<T>)
            - NoneMatch(Predicate<T>)
            - sum()
            - count()
            - reduce(BinaryOperator<T>)

** 22:00 Example check author
    - check if all books have author
    - get all books with author
        - stream().allMatch(b -> b.getAuthors().size() > 0)
    - get total number of pages 
        - stream().mapToInt(Book:getNumPages).sum()
    - get maximum number of pages
        - steam().mapToInt(Book::getNumPages).max().orElse(0)

** 30:00 Optional<T>
    - datatype met optionele waarde
    - wordt door sommige reducers gegeven
    - als er stream leeg is, of er is geen match vanwege een filter, dan is 
      Optional<T> ook leeg
    - methodes
        - get(): als bestaad: waarde van T, ander exception 
        - orElse(): als bestaad: waarde van T, defaultValue van type T
        - isEmpty, als bestaad: false, anders true

** 32:00 Reduce method
    - implementeert incrementele gegevensaggregatie (zoals elke reducer)
    - is een abstract reducer, je kan zelf implementeren
    - vereist een associatieve BinaryOperation, functie met twee parameters
    - signature
        - identity
            - initiele waarde van de reduction methode
            - standaar resultaat als de stream leeg is
        - accumulator
            - heeft twee parameters, waar van een de output is van de
            reductie operator en hte volgende element van de stream
        - combinor

    - accumilator is taking the partial result of the reduction operation in
      some, i'll type some excample in the chat

    - reduce(BinaryOperator<T> accumulator)
        - alleen een accumulator, reducer start leeg 
    - reduce(T identity, BinaryOperator<T> accumulator)
        - bereken sum van elementen
            - reduce(0, (subtotal, element) -> subtotal + element);
    - reduce(U identity, BiFunction<U ? super T, U> accumulator, BinaryOperator<T> combinor)
        - identity, accumulator, combiner 
        - bifunciton similar to binary operator
            - two arguments of type t and u and type R

        BI Function = A function with two arguments of types T and U and a result of type R
        BinaryOpertator = A function with two arguments of type T and the same result type T

        - if the subtotal en the element of our accumulation operation are
          two different types kan je compilatie problemen hebben
        
        - if we use sequencial streams and the types of the accumilator
          arguments and the types of the implementation match, then we dont
          need to use a combiner
        - if we are using a paralel stream split into stream we have to use a
          combiner to combine the results of a single stream

** 44:00 Reducer example
    - vindt boek met langste titel
        stream().reduce( (b1, b2) -> 
            (b.getTitle().length() > b2.getTitle().length() ? b1 : b2)
        ).get()

** 60:00 Collectors
    - verzamelt invoerelementen in een resultaat container
    - eventueel verkleinen en / of transformeren naar een definitieve
      representatie 
    - interface Collector<T, A, R>

    - example build set of all books before 2000
        - .stream().filter(b -> yearOfIssue < 2000).collect(collectors.toSet())

    example collectors
        - steam to Collection
            - toList()
            - toSet()
        - stream to string
            - joining(delimiter, prefix, postfix)
        - stream to map
            - toMap(keyMapper, valueMapper, merge)
            - groupingBy(classifier)
        - statistics calculators
            - averagingDouble(mapper)
            - summarizingDouble(mapper)
            - maxBy(comparator)
            - minBy(comparator)
        - generic reducer
            - reducing(identity, binaryOperator)

** 65:00 collectors example code
    - calculate average numer of authors per book
        .stream()
        .collect(Collectors.averagingDouble(b -> b.getAuthors().size()))
    - maak een lijst met alle titels van boeken met meer dan 3 auteurs
        .stream()
        .filter(b -> b.authors.size())
        .map(Book::getTitle)
        .collect(Collectors.joining("\n", "- book titles", "-"))

** 72:00 flatmap
    - hoe vindt je alle authors dat een boek hebben gepubliceert voor 2000
    - steam boeken, filter voor 2000, map boek naar auteur, collect auteur
    - code
        .stream()
        .filter(b -> b.yearOfIssue < 2000)
        .flatMap(b -> b.getAuthors().stream())
        .collect(Collectors.toSet())

** 76:00 collecting into a map
    - maak een Map<K,V> van een Stream<T>
    - toMap()
        - toMap(Function<T,K> keyMapper, Function<T,V> valueMapper, binaryOperator<V> merger)
    - groupingBy()
        - vergelijkbaar met group by in SQL
        - groupingBy(Function<T,K> keyMapper, Collector<T,?,V> reducer)

** 79:00 code example
    - maak een lijst van alle auteurs met totaal nummer van gepublisheerde boeken 
        .stream()
        .flatMap(b -> b.getAuthors().stream())
        .collect(Collectors.toMap(a -> a,a -> 1, math::addExact))

** 82:00
    - maak een lijst van alle auteurs met totaal aantal van gepublisheerde boeken
        .stream()
        .flatMap(b -> b.getAuthors().stream())
        .collect(Collectors.groupingBy(a -> a, Collectors.counting()))

** 89:00 Stream<Double> vs DoubleStream
    - concept is hetzelfde maar implemenatatie is anders
    - Stream<Double>
        - een stream van Double objecten
        - Naar DoubleStream: .mapToDouble(x -> x)
        - geeft extra method: .collector(Collector)
    - DoubleStream
        - een primitive Stream van primitive doubles
        - naar Stream<Double>: .boxed()
        - geeft extra method: .average()

** 91:00 sorted streams
    - sorteer een stream met .sorted(Comparator<T>)
    - extra functies: .dropWhile(Predicate<T>), takeWhile(Predicate<T>)
    - nadeel: maakt stream minder efficient

** 93:00 Stream operations
    - moeten niet interferend zijn, niet bron van de stream aanpassen
    - in de meeste gevalen staatloos zijn, niet afhankelijk van veranderingen
      in de staat tijdens het uitvoerenin de pipeline 
    - vermijden van bijwerkingen, veranderen van globale data buiten de scope
      van de pipeline

** 94:00 streams can't be forked
    - na de terminal operation can de stream niet meer gebruikt worden
    - bijvoorbeeld geen .count() na dat je .sum() hebt uitgevoerd.

* 3, lecture 10, 2020-11-25
Tree, Binary tree and traversals, Binary Search Trees


** 00:00 Tree
    - een tree is een type graaf
    - eigenschappen tree
        - connected graaf zonder cyclus 
        - een edge toevoegen zou een cyclus maken
        - als je een edge weg haalt is de graaf opgebroken 

** 05:00 Recursieve definitie
    - een tree kan leeg zijn
    - een tree is a node verbonden tot een eindig aantal bomen (subtrees)
    - een sub-tree is een subset van trees bestaande uit nodes met hun
      nakomelingen
    - eigenschappen
        - een boom met n nodes heeft precies n-1 edges
        - er is excact een path tussen elke paar van nodes 

** 07:00 directed tree
    - een tree is een gerichte graaf
    - graad is het aantal of kinderen connected
    - eigenschappen
        - er is exact een node met input graad gelijk aan 0, dit is de
          root node
        - elke andere node heeft een input graad van 1
        - elke node heft een gericht pad van de root naar die node 
    - een tree zonder nodes is een null of empty tree

** 12:00 tree terminology 1
    - node
        - element in de tree
    - edge / brench
        connectie tussen twee nodes
    - path
        - route door tussen nodes in de tree
    - predecessor
        - parent van een node
    - ancestor
        - node verder omhoog in de tree op een pad
    - successor
        - child of a node
    - descendant
        - node verder omlaag in de tree op een pad

** 14:00 terminology in trees 2
    - root
        - level 0
        - node heeft geen predecessor
        - alle andere nodes hebben exact een predecessor
    - leaf node heeft geen successor
    - successor(s) van een node at level n is op level n+1
    - depth is hetzelfde als level

** 15:00 implementation
    - Tree klasse
        - bevat root Node
        - find(), insert(), delete(), methods
    - node klasse
        - LinkedList of ArrayList van kind nodes en mogelijk parent node
        - alle nodes in the list van child nodes wijzen naar een andere tree
          nodes

** 16:00 binary tree
    - is een tree waar elke node een graad heeft van maximaal twee
    - bestaat uit een root, een linker sub-tree, en een rechter sub-tree
    - elke sub-tree van een binary tree heeft opnieuw een root, een linker
      sub-tree en een rechter sub-tree-
    - sub-trees kunnen leeg zijn

** 21:00 binary tree implementatie
    - linked
        - node klasse
            - veld voor parent, linker, en rechter node
    - array
        like a heap

** 25:00 traversing de tree
    - nodes van een binary tree kunnen vermeld worden in een specifieke
      volgorde
    - mogelijkheden
        - preorder: root, left, right
        - inorder: left, root, right
        - postorder: left, right, root

        - preoder: naar beneden, links van node
        - inorder: naar rechts, onderkant van node
        - postorder: naar boven, rechts van node

** 53:00 binary search tree (treeSet)
    - treeSet
    - storing data in a tree to speed up seach
    - data moet sorteerbaar zijn (Comparable)
    - links is kleiner, rechts is groter 

** 56:00 Binary search tree
    - TreeMap
    - BST
    - elke node heeft een key, value
    - binary tree in symmetrishe volgorde 
    - links is kleiner, rechts is groter 

** 58:00 adding an element to BST
    - beweeg naar de root 
    - als item links < item in node, ga naar links, anders naar rechts
    - als child leeg is sla je item daar op, anders herhaal

** 61:00 Searching to BST
    - start van af de root node
    - if item = item in node, found
    - if item < item in node, ga naar linker positie, anders ga naar rechter
      positie
    - als de child leeg is het niet gevonden, ander herhaal
    - efficiency
        - gemiddeld: O(log n)
        - worst case: O(n)

** 68:00 BST (treeMap)
    - node klasse 
        - velden: key, value, node left, node right

** 68:00 BST API
    - BST klasse
    - methodes
        - put toevoegen
        - get opvragen
        - delete verwijderen
        - Iterable iterator

** 70:00 Get
    - geeft de waarde geassocieerd met sleutel of null als de key niet
      aanwezig is
    - instructie while loop
        - maak een node variable aan met als waarde root
        - start een while loop zo lang de node variable niet null is
        - vergelijk de key met de waarde die je zoekt
        - als het lager is pak de linker node, anders rechter node
        - als het gelijk is return 
    - instructie recursion
        - public methode roept private recursive methode met root en key
        - als node null is return null
        - vergelijk de key met de waarde die je zoekt
        - als het lager is roep methode met linker node, anders rechter node
        - ander return waarde

** 73:00 put
    - recursion
    - zoek voor key
    - als de key in de tree zit reset de waarde
    - als de key niet in de tree zit voeg een nieuwe node toe
    - reset references op de weg omhoog

** 77:00 shape of the tree
    - afhankelijk van de volgorde waar in je items toe voegt
    - best case: verdeeld 
    - worst case: alles links of alles rechts 
    - heeft invloed op de prestatie

** 78:00 Balanced search trees
    - om worst case scenario's te voorkomen zijn
    - red-black trees
        - automatisch balanceert
        - symetrich 
        - gebruikt door Java voor TreeMap implementatie 
    - passen hun root node aan om gebalanceerd te blijven op een manier dat
      volgorde van toevoegen niets uit maakt 

** 80:00 binary expression tree
    - expressions in a tree
    - methode om wiskundige expressie uit te beelden
    - rekenkundige en logische uitdrukkingen in een boom
    - variabelen vormen de bladeren
    - operators zijn altijd de root van een sub-tree 

** 92:00 order bases method
    - vindt minimum
    - vindt maximum
    - floor
        - grootste key <= aan een geven key
        - floor(g) = e
        - floor(d) = c
    - ceiling
        - kleinste key >= aan een gegeven key
        - ceiling(q) = r

** 96:00 bereken de floor
    - te zoeken key is k
    - als k gelijk is aan root is root de floor
    - als k kleiner is dan root
        ga naar links 
    - als k groter is dan root
        - floor is in de right sub tree als er een key kleiner dan k is in
          the right sub tree
        - ander is het de key van de root

** 101:00 rank and select
    - rank
        hoe veel key < k
    - select
        - key van gegeven rank
    - elke node houd het aantal subnodes bij

** 00:00
    - 

** 00:00
    - 

** 00:00
    - 

** 00:00
    - 

** 00:00
    - 

** 00:00
    - 

** 00:00
    - 

** 00:00
    - 

* 4, lecture 11, 2020-12-02
Undirected Graph, Minimal Spanning Tree

** 02:00 graaf
    - datastructuur met nodes en edges 
    - nodes worden verbonden door edges
    - gebruikt in: route kaart, sociale connecties, file system, kracht
      balans, logistiek, beslissingsondersteuning

** 20:00 path
    - simple path: pad zonder herhalende nodes 
    - cycle: pad waar de start en eind node hetzelfde zijn
    - connected graph: path van elke node naar elke andere node
    - disconnected graph: niet elke node is met een pad te verbinden
    - directed: edges zijn een richting 
    - undirected: edge kan beide kanten op
    - weighted graph: edges hebben waardes (afstand, kosten)

    - euler path: pad waar alle connecties een keer gebruikt worden
    - euler circuit: ealer path dat start en eindigd op dezelfde node 
    - euler graph: een graaf met een euler cycle
    - semi-euler path: een graaf met een euler path, maar zonder cycle

    - graaf heeft een euler path als
        - het connected is
        - er exact twee nodes zijn met een oneven degree

    - graaf heet een euler circuit als
        - graaf verbonden is
        - alle vertices een even degree hebben

** 40:00 Hamilton
    - hamilton path: een pad waar je alle knopen precies een keer bezoekt
    - hamilton cycle: een pad dat eindigd waar je start 
    - hamilton graph: een graaf met een hamilton cycle
    - semi-hamilton path: een graaf met een hamilton path, maar zonder cycle

** 42:00 Traveling salesman problem
    - vindt het het korste pad tussen alle nodes 
    - np-complete: verschillende problemen met dezelfde aanpak
    - complexity O(2^n)
    - alle mogelijke paden uitrekennen

** 55:00 Tree
    - is een graaf
    - verbonden graaf zonder cycles
    - aantal edges is altijd 1 minder dan het aantal nodes
    - weghalen van een edge maakt het disconnected
    - toevoegen van een edge maakt een cycle
    - elk paar van nodes heeft een pad

** 57:00 spanning tree
    - spannings boog
    - spanning tree van een connected graaf is een tree waar in
        - alle nodes zijn gebruikt
        - alle edges van de tree ook in de graaf voorkomen

** 61:00 implementatie
    - adjecency list
        list met sub-lists
    - edge klasse
        - from en to node
        - implementeerd hashCode en equels
    - vertex klasse
        - HashSet met edges

    - adjecency matrix
        - matrix van 2 dimensionale array van number
        - representeerd verbinding tussen nodes
        - beter voor een graaf die er erg dense is
        - row uitgaande verbinding, column inkomende verbinding
        - 1 is verbinding, 0 is afwezigheid van verbinding


** 85:00 Depth first search
    - vindt pad van begin naar eind 
    - bijvoorbeeld steeds recht blijven lopen in een doolhof
    - algoritme
        - gebruik recursie
        - track bezochte nodes en back-track wanneer er geen mogelijkheden
          meer zijn 
        - bouw het pad terug wanneer target gevonden is
    - data 
        - verzamelling bezochte nodes
        - queue van edges voor het pad

** 96:00 Breath first search
    - in plaats van diepte de breedte
    - eest neighbours voor dat we een level dieper gaan
    - in plaats van recursie gebruik je een queue

* 5, lecture 12, 2020-12-09
Path Searching, Dijkstra Shortest Path

** 01:00 minimum spanning tree
    - een weighted grafp is een graaf waar de edges een gewicht hebben
    - gewicht
        - afstand
        - reisttijd
        - weerstand in een elektrisch 
        - verschil van hoogte

** 07:00 mimimum spanning trees
    - in een weighted graph is de minimum spanning tree een tree waar van de
      sum van gewichten minimaal is
    - alle nodes moeten verbonden zijn
    - edges hebben een positief gewicht
    - als edges hetzelfde gewicht hebben kan het zijn dat er meerdere MST zijn

** 09:00 Cut property
    - een cut is een divisie van nodes in twee niet empty en niet
      overlappende subsets dat alle nodes bevatten 
    - de edge tussen de nodes van de subsets met het laagste gewicht zit per
      definitie in de MST
    - dit wordt gebruikt in zoek algoritmes

** 10:00 Greedy algorithm
    - begin met een graaf met V nodes
    - markeerd alle edges van de MST 
    - nadeel: is niet altijd efficient
    - operatie
        - kies een cut waar geen gemarkeerde edge in zit
        - kies een lijn met het laagste gewicht en markeert het
        - als er minder dan V-1 edges gemarkeerd zijn, herhaal

** 12:00 Prim's algorithms
    - als een soor uitspreidende vlek
    - operatie
        - kies een willekeurig punt
        - maak een cut waar aan een kant de start node zit
        - voeg de edge met het laagste gewicht toe aan de mst
        - maak een cut met de de nodes van de MST en de rest
        - herhaal

** 18:00 Kruskal's algorithm
    - als een bos dat uiteingelijk naar een grote tree groeit
    - sorteer de edges naar oplopend gewicht 
    - efficiente manier voor cycle test
    - beginnen met een graaf met V nodes 
    - operaties:
        - kies de edge met het laagste gewicht dat geen cycle maakt met de
          edges in de MST en voeg het toe aan de MST

** 22:00 Data structure for MST
    - klasse Edge
        - tot nu toe werden alleen links tussen nodes gerepresenteerd
        - maak een klasse voor edge met de velden van en naar node en weight.
    - klasse EdgeWeightedGraph
        - veld voor het aantal nodes en een adjecency list voor edges

** 35:00 weighted directed graph
    - er bestaat geen pad tussen alle nodes ook is de graaf connected
    - follow arrow direction
    - gewicht groter of gelijk aan 0

** 37:00 shortest path algorithms
    - maakt shortest path tree van star node naar iedere toegankelijke node van de graaf
    - algoritmes
        - dijkstra
        - floyd
        - a*

** 38:00 Dijksta's shortest path
    - gepublisheerd in 1959
    - start van af een begin punt
    - extend de spanning tree met een edge dat je de kortste afstand geeft
      van af de start node
    - operatie
        - van af de start node kijk naar de aanliggende node met de laagste weight
        - noteer de weight van af start naar de de node 
        - ga verder met de edge met het laagste totaal gewicht

    - datatypes
        - distTo
            - array waar de afstand van af de start wordt opgeslagen
            - initieel waarde oneindig, behalve voor start
        - edgeTo
            - bewaard de node van waar mee het is verbonden in de MST
            - start heeft geen edgeTo

** 50:00 relexation
    - Als er naar een node een path gevonden is met een weight dat lager is
      dan de huidige weight wordt het orginele path vervangen met het nieuwe
      path
    - distTo en edgeTo worden bijwerken

    - selecterd node met de laagste distTo
    - relax alle edges die start met die node door te controlleren of nieuwe
      weight kleiner is dan bestaande weight, wanneer dat het geval is update
      data
    - markeer node als bezocht 
    - herhaal tot alle nodes nodes bezocht zijn 

* 6, lecture 13, 2020-12-16
Graph Search Heuristics, A\*-search

* 7, lecture 14, 2021-01-06
State Machine Algorithm
