\section{Tree}
Dit hoofdstuk bespreekt trees, wat een type graaf is.
Het heeeft de eigenschappen:
Heeft geen cyclus, een edge toevoegen zou een cyclus maken, als je een edge weg haald is de graaf opgebroken.
Een tree kan leeg zijn.

Recursieve definitie:
Is een node verbonden tot een eindig aantal bomen (sub-tree).
Een sub-tree is een subset van trees bestaande uit nodes met hun nakomelingen.
Eigenschappen: een boom met n nodes heeft precies n-1 edges
Er is excact een path tussen elk paar van nodes

Graad is het aantal verbonden childeren van een node

\subsection{Directed tree}
Een tree in een gerichte graaf.
Er is exact een node met input graad gelijk aan 0, dat is de root node.
Elke andere node heeft een input graad van 1
elke node heeft een gericht pad van de root nar die node.

\subsection{Terminologie}
\textbf{Node}: Element in de tree.
\textbf{Edge}: Connectie tussen twee nodes.
\textbf{Path}: Route tussen nodes in de tree.
\textbf{Predecessor}: Parent van een node.
\textbf{Ancestor}: Node verder omhoog in de tree op een pad.
\textbf{Successor}: Child van een node.
\textbf{Descendant}: Node verder omlaag in de tree op een pad.
\textbf{Root}: Node op level 0, heeft geen predecessor.
\textbf{Leaf}: Node zonder sucessor.
\textbf{Depth}: Afstand van root node (level).

\subsection{Implementatie}
Tree klasse bevat root node, heeft methodes voro \texttt{find}, \texttt{insert()}, \texttt{delete()}.
Node klasse bevat een LinkedList of een ArrayList van child nodes.
Alle nodes in de lijst van child nodes wijzen naar een andere tree nodes.

\subsection{Binary Tree}
Is een tree waar elke node een maximale graad heeft van twee, dus maximaal twee children heeft.
Bestaat uit een root, een linker sub-tree, en een rechter sub-tree.
Sub-trees kunnen leeg zijn.

Implementatie: \textbf{LinkedList}, node klasse met veld voor parent, linker, en rechter node.
\textbf{ArrayList}, zoals in een heap.

\subsubsection{Traversing}
Nodes in een binary tree kunnen vermeld worden in een paar specifieke volgorde.
\textbf{Preorder}: root, left right, naar beneden, links van node.
\textbf{Inorder}: root left right, nar rechts, onderkant van node.
\textbf{Postorder}, left right root, naar boven, rechts van node.

\subsubsection{Binary search tree BST}
Het opslaan van data in een tree om zoeken te versnellen, data moet sorteerbaar zijn (Comparable).
Nodes links zijn kleiner dan root, nodes recht zijn groter dan root.
\textbf{TreeSet}: Nodes zijn waardes.
\textbf{TreeMap}: Nodes zijn een key, value paar.

\subsubsection{Element toevoegen}
\textbf{TreeSet}: Beweeg element naar root positie.
Als node groter is dan element ga naar links, anders naar rechts.
Als child leeg is sla je item daar op, ander herhaal.
\textbf{TreeMap}: Door middel van recursie zoeken naar de juiste key.
Als de key in de tree zit vervang de waarde.
Als de key niet in de tree zit voe een nieuwe node toe.
Reset de referenties op de weg omhoog.

\subsubsection{Search}
Start bij de root node.
Als het element gelijk is aan de nodige is het gevonden.
Als node groter dan element ga naar links, anders naar rechts.
Wanneer child leeg is is het niet in de collectie, anders herhaal.
De efficientie is gemiddeld $O(\log n)$ en is het slechtse geval $O(n)$.

\subsubsection{Search TreeMap}
Geef de waarde geassocieerd met de sleutel of null als de key niet gevonden kan worden.
\textbf{While Loop}: maak een node variable aan met waarde de root node.
Start en while loop zo lang de node variable niet null is.
Vergelijk de key met de waarde die je zoekt.
Als he lager ipak de linker node, ander rechter node.
Als het gelijk is return.
\textbf{Recursie}: Roep private methode aan met node en key.
Als node null is return null.
Vergelijk de key met de waarde die je zoekt.
Als het lager is roep de methode met linker node, ander met rechter node.
Return anders de waarde.

\subsubsection{Balanced BST}
Te voorkomen dat een BST minder efficient wordt omdat te onsymetrisch wordt, bijvoorbeeld door element op gesorteerd volgorde toe te voegen.
Zorgen Red-Black trees er voor dat het automatisch balanceert, wordt gebruikt in de Java implementatie.
De root node wordt aangepast om gebalanceert te blijven zo dat de volgorde van toevoegen niet uitmaakt.

\subsubsection{Binary Expression tree}
Manier om wiskundige uitdrukkingen uit te beelden in een tree.
Variablen in de expressie vormen de bladeren, operators zijn altijd de root van sub-trees.

\subsubsection{Order basesd method}
Het vinden van 
\textbf{floor}: Het eerste element lager dan een waarde.
Grootste waarde <= gegeven waarde.
\textbf{ceiling}: Het eerste element hoger dan een waarde.
Kleinste waarde <= gegeven waarde.

\subsubsection{Floor berekenen}
Te zoeken key k, als k e gelijk is aan root is root de floor.
Als k kleiner is dan root ga je naar links.
Als k groter is dan root, floor is de rechter sub-tree als er een key kleiner is dan k in de rechter sub-tree, anders it het de key van root.
