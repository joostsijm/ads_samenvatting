\section{OOP}
% OOP (references, wrappers, generics, interfaces), abstract datatypes, interator, Recursion, Comparator, Big-O efficiency
Dit hoofdstuk beschrijft de onderwerpen die onder \textit{object oriented programming} vallen, zoals: references, wrappers, generics, interfaces.
Maar ook enkele geleateerde onderwerpen waar voor geen andere toepasselijk hoefdstuk is. Zoals: abstract datatypes, interator, Recursion, Comparator, Big-O efficiency

\subsection{Objectgeoriënteerd programmeren}
\index{OOP} wordt gebruikt om de echte wereld te modeleren.
Voorbeelden daar van zijn \textbf{luchtverkeersleiding}: vliegtuigen, vliegvelden, vluchten; \textbf{account systemen}: klant, account, transactie; \textbf{tekst verwerker}: letter, woord, lettertype, formaat.
Wordt toegepast voor voor medium tot grote applicatie, goed schaalbaar.

\subsubsection{Systemen}
Objectgeoriënteerde systemen zijn samengesteld, modulair en georganiseerd rond data.
Het is de beste strategie voor grote, evoluerende softwaresystemen.
Een klasse representeerd een stuk data.
Het forceert, in de meeste gevallen, ontwerpen voor programmeren.

\subsubsection{Modularisatie}
Hierbij breken we iets, een applicatie, op in kleine beheersbare stukken.
Kleinere onderdelen zijn makkelijker om mee te werken, in een team, en te testen.

\subsubsection{Fundamentele eigenschappen}
\textbf{Erfenis} (inheritance): mogelijkheid om af te stammen van andere objecten.
Methodes uit de ouder kunnen overschreven worden, methode behoud de naam, dynamische binding laat polymorphisme toe.
\textbf{Inkapseling} (encapsulation): beperken van controlle over de manier een object gemanipuleerd kan worden.
Private properties, public get, set, en andere methodes.
\textbf{polymorfisme} (polymorphism): vermogen van een object om verschillende vormen aan te nemen.
Zorgt voor minder korte koppeling door erfenis.

\subsubsection{Klasse}
Werken als een sjabloon voor een object.
Specificeert de eigenschappen van een groep vergelijkbare objecten.

\subsubsection{Objecten}
Dit is de fundamentele abstractie waar op we onze systemen bouwen.
Een object is een instantie van een klasse in het geheugen.
Het heeft drie karakter eigenschappen: \textbf{Staat}: velden, \textbf{gedrag}: methodes, \textbf{identiteit}: hoe we verwijzen naar object.

\subsubsection{Relaties}
Objecten werken samen en zijn verbonden met andere objecten.
Ideaal minimalizeer je korte koppeling, hoge afhankelijkheid, tussen objecten.
Zonder interactie tussen objecten is er geen werkend systeem.
Mogelijkheden om objecten te verbinden:
\textbf{Associate}: connectie met ander object, eventueel een kardinaliteit, kunnen los van elkaar bestaan.
\textbf{Aggregratie}: een groepering van objecten, object kan tijdelijk deel uitmaken en los bestaan.
\textbf{Compositie}: een samengestelde groep van objecten, kunnen niet los bestaan, hebben een korte koppeling.
\textbf{Erfenis}: object stamt af van een ander object (ouder kind relatie), is een korte koppeling.
Door middel van sub-classing kan er extra functionaliteit worden toegevoegd.

\subsection{Abstractie}
We denken hier over iets als een idee, we negeren de irrelevante details en leggen de nadruk op de essentiele details.
Zonder ons zorgen te maken over de details verwijderen we de essentiele dingen die alle soorten gemeen hebben.
Bijvoorbeeld: een abstracte auto bestaat uit een abstracte motor en abstacte wielen, maar bijvoorbeeld kleur onbetekenend voor het idee van een auto.
Abstractie zorgt voor een lage koppeling tussen objecten, veel ontwerp patronen zijn hier op gebaseerd

\subsubsection{Abstracte klasse}
Kan niet geïnstantieerd worden, vaak is dit in het ontwerp niet wenselijk of logisch.
Een voorbeeld kan zijn: een vorm, je zou het niet kunnen tekennen zonder het figuur te weten.
Definieert het type en heeft een constructor, een ouder en kan ouder zijn van een (abstracte) klasse.
Kan (abstracte) methodes en instance fields hebben.

\subsubsection{Interface}
Functioneert als een belofte van gedrag (methodes), van de klasse die het implementeerd.
Is een puur abstracte klasse om gedrag te defineren met minimale functionaliteit en heeft geen constructor, alleen abstracte methodes.

\subsection{Abstracte data types}
Zijn datatypes war van de implementatie van de methodes verborgen is.
Bevat data specefie voro een instante van de abstracte data type met methodes om deze data te bewerken.
De data is ingekapseld, het toont slechts enkele van de subprogramma's.
Bijvoorbeeld een list pebruikt een array en laat de gebruiker door middel van een interface bewerken.
Voor komt direct bewerken van de indices in de array.

\subsubsection{Generics}
Java is een statisch getypeerde programmeertaal, types moeten van te voren gedefineerd zijn.
Een generics zorgt er voor dat een abstracte data type geparametriseerd kan worden.
Het zorgt er voor dat het type pas later gespecificeerd kan worden, de generic functioneert als een parameter in de klasse declaration.
Zonder zou ieder object in ongecontrolleerd in een collectie toegevoegd kunnen worden.
Bij het ophalen van het object moet het eerst gedowncast worden om te gebruiken.

\subsubsection{Java collections API}
Java implementatie van abstracte data types, \textit{java.util.Collection}.
Zijn gebaseerd op \textbf{AbstractCollection} en implementeren de \ interface \textbf{Collection}.
Bevat bijna ieder type van collectie.

\subsubsection{Iterable}
Is een interface dat door een collectie geimplementeerd word, returned \textbf{Iterator}.
Dat is ook een interface, geimplementeerd door een private klass binnen de collectie klasse bevat \textit{hasNext()} en \textit{next()} methodes.
Maakt het makkelijk om een collectie in een loop te zetten.
Een \textbf{for each} is een shorthand versie van een while loop die gebruikt maakt van de iterator.

\begin{center}
    \begin{tabular}{ll}
        Naam        & Omschrijving \\
        \midrule
        ArrayList   & Resizable  array - groeit incrementeel \\
        Hashmap     & Een collectie van [key, data] paren - ongeordend \\
        HashSet     & Set door middel van een hash table - ongeordend \\
        Hashtable   & Een collectie van [key, data] paren - ongeordend \\
        LinkedList  & Een gekoppelde lijst \\
        Stack Last  & Laatste er in, eerste er uit (LIFO) data structuur \\
        TreeMap     & [key,data] paren, gehouden in aflopende volgorde \\
        TreeSet     & Sit geimplementeerd als een tree \\
        \bottomrule
    \end{tabular}
\end{center}

\subsection{Primitive types}
Zijn de meest primitieve versie van een data type, zijn geen objecten en kunnen daarom niet in een collectie gebruikt worden.
Door middel van een wrapper klasse wordt de waarde van de primitieve variable in een object vastgehouden.
Bijvoorbeeld: int, Integer.
De wrapper klasse heeft ook meer functies, zoals bijvoorbeeld het parsen van een \textit{String} met \textit{Integer.parseInt()}.
Door middel van autoboxing worden primitieve types automatisch in een wrapper geplaatst.
De wrapper versie van een primitieve klasse is minder snel.

\subsection{Recursie}
Krijg je door het aanroepen van een methode binnen de methode zelf, op die manier ontstaat er een oneindige loop.
Het stoppen van deze loop wordt gedaan door een stop conditie, dat zorgt er voor dat de methode niet meer aangeroepen wordt.
Recursie is soms nodig voor effectief oplossen van problemen, bijvoorbeeld het doorlopen van een tree, of een grootst gemene deler vinden.
De volgorde van statments is belangrijk, het bepaald hoe de data gemanipuleerd word doordat de methode eerst uitgevoerd wordt voor dat de methode verder gaat.

\subsubsection{Methode aanroepen}
Methodes bestaan uit code en data, deze data bestaat uit parameters en locale variablen.
Bij het aanroepen van de methode belanden de data in een stack frame, die bevat ook het return address van de functie.
Deze frame wordt weg gegooid na dat de methode is uitgevoerd.

\subsubsection{Gebruik}
Om het concept van recursie te gebruiken hoef je niet te weten hoe het precies werkt.
Het is genoeg om te weten wat een recursieve methode doet.
In wiskunde is het te vergelijken met inductie, vaak volgt een recursieve methode de natuur van de data.

\subsubsection{Types}
Verschillende manier om op een oplossing te komen.
\textbf{bottom-up}: start van af het begin, \textbf{top-down} start van af het einde, \textbf{bisection}, start in het midden

\subsection{Comparator}
Wanneer een klasse dit implementeerd kan het vergeleken worden met een andere instantie van deze klasse.
Door middel van de \textit{compareTo()} methode die in de klas is geimplementeerd.
De methode heeft een ander object als parameter waar het dan mee vergelijkt wordt en returned een integer.
Als de huidige instantie voor de megegeven instantie moet komen geeft het iets kleiner dan 0, anders hoger dan 0, als het gelijk is geeft het 0 terug.
De meeste standaard klassen implementeren de comparator, dit gebeurt op natuurlijke ordering: A-Z, a-z, 0-9, etc.

\subsubsection{Comparator}
Is een extra sorteert klasse, die binnen of buiten de klasse gedeclareerd kan worden.
Zorgt er voor dat je op andere manieren kan sorteren.
Vergelijkt twee instanties van klassen met de \textit{compare} methode.

\subsection{Big-O efficiency}
In het efficient maken van een algoritme is het vaak een afweging tussen tijd en ruimte (geheugen).
Hogere tijd efficiëntie betekend vaak lage ruimte efficiëntie, en een hoge ruimte efficiëntie betekend vaak een lage tijd efficiëntie.
\textbf{Algoritme} is de manier dat je een probleem oplost, in informele definitie is een algoritme een stap voor stap methode om een probleem op te lossen, als een recept. Het geeft een andwoord op je probleem. Bijvoorbeeld, bakken van een cake, berekennen van een vorm, vinden van data in een grote database, sorteren van een set data.
\textbf{Data structuur} de manier dat je de data opslaat heet een data structure. Het is een manier waar op je de data op een computer hebt opgeslagen.
Een implementatie van een data opslag.
Bijvoorbeeld: Array, List, Stack, Queue, Hashmap, Tree, Graph.

Afhankelijk van je algoritme kan je een bepaalde data structuur kiezen, of afhankelijk van de data structuur moet je een bepaald algoritme kiezen.
Bijvoorbeeld een binaire boom of een linked list hebben eigen efficiente algoritmes.

\subsubsection{Birthday paradox}
Hoe kan je van een groep mensen matchende geboorte datums vinden.
Vergelijking van twee oplossingen.
\textbf{Oplossing 1}, sla alle datums op in een array, controller per datums met de ander datums in een dubbele for loop.
De tijd efficiëntie is $O(n^2)$, exponentiele stijging naar mate van datums, ruimte efficiëntie is hoog omdat je niets bijhoud.
\textbf{Oplossing 2}, een array maken voor alle 366 dagen van het jaar met waarde 0.
Voor in je van iedere datum de dag in de array verhogen met 1.
Controlleer de array waar de dagen meer dan 1 is.
De tijd efficiëntie is O(n), de stijging is constant, ruimte efficiëntie is constant maar gebruikt in vergelijking veel als je weinig datums heb.

\subsubsection{Efficiëntie array}
\textbf{Toevoegen}, een element wordt aan het einde van de array toegevoegd, is gebeurt ogenblikkelijk, onafhanklijk van lengte.
\textbf{Vinden}, vergelijken van elk element tot je ee match hebt.
Gemiddeld vergelijk je de helft van de elementen in de array.
Met een twee keer zo lange lijst heb je twee keer zo veel vergelijkingen.
\textbf{Verwijderen}, elk element na het te verwijderen element moet een plek terug verplaatst worden.
Efficiëntie ongeveer even gelijk als vinden.

\subsubsection{Algoritmische complexiteit}
Er kan onderscheid gemaakt worden tussen twee soorten complexiteit.
\textbf{Tijd complexitet} is de relatie tussen aantal elementen en benodigde tijd.
\textbf{Ruimte complexiteit} is de relatie tussen aantal element en benodigd geheugen.
In een algoritme maak je een overweging tussen de twee.

\subsubsection{JVM}
In de Java Virtual Machine wordt code geoptimaliseerd.
Dit gebeurt door uitkomsten te controlleren en maakt aanpassingen in de runtime als het een snellere route ziet.
Dit heet JIT (Just In Time) en kan uitgeschakeld worden met de \textit{-Xint} parameter.

\subsubsection{Big O}
Beschrijft de notatie van de orde van grote.
$O(n^2)$ betekend een exponentiele stijging naar mate de input groter wordt.
$O(\log N)$ betekend logaritme, het omgekeerd van een exponent, het zal minder snel stijgen naar mate de input groeit.
Een dubbele loop betekend al vaak exponentieel.
Voor programming gebruiken we weinig nauwkeurigheid, $O(1+N+N^2)$ wordt afgekort naar $O(N^2)$.

\begin{center}
    \begin{tabular}{ll}
        Big-O                           & Omschrijving \\
        \midrule
        $O(1)$                          & Constant \\
        $O(\log N)$                     & Logaritmisch \\
        $O(\sqrt{N}) = O(N^{0.5})$      & wortel n \\
        $O(N)$                          & Lineair \\
        $O(N \log N)$                   & n log n \\
        $O(N \sqrt{N}) = O(N^{1.5})$    & n wortel n \\
        $O(N^2)$                        & Kwadratisch \\
        $O(N^3)$                        & n tot de macht 3 \\
        $O(a^N)$                        & 57 \\
        \bottomrule
    \end{tabular}
\end{center}
